#### 문제 
https://www.acmicpc.net/problem/1939



#### 설명

파라메트릭 서치 : 최적화 문제(어떤 값의 최대, 최소 구하는 문제 )를 결정문제(답이 yes, no)로 바꾼 뒤 이분 탐색을 이용해 최적해를 찾는 알고리즘 

//답이 [a, b]구간 내에 존재한다 할 때,
int lo = a - 1, hi = b;
while (lo + 1 < hi) {
	int mid = (lo + hi) / 2;
	if (!check(mid)) lo = mid;
	else hi = mid;
}
*/

bfs가 성공했다 -> 이게 최선이거나, 더 좋은 값이 존재하겠지? -> s 구간을 현재 mid이상으로 잡아도 s는 아직 성공하는 구간값임!

s는 항상 성공하는 위치
e는 항상 실패하는 위치

#### 소스 

````
#include <bits/stdc++.h>

using namespace std;

int n, m, start, End;
// 4 * 4 => 14  
vector<pair<int, int>> Info[10001];
/*
vector가 10001개가 있다 
Info[now]를 하면 나온 것이 벡터이다 
*/
bool bfs(int &x) {
	
	int flagCost = x; // 해당 비용으로 가능한가 ? 
	bool visited[10001] = { false, };
	queue<int> q;
	q.push(start);
	visited[start] = 1;

	while (!q.empty())
	{
		int now = q.front(); q.pop();

		for (int i = 0; i < Info[now].size(); i++) {

			if (visited[Info[now][i].first]) continue;  // now 다리에서 i로 갔냐? pass 

			int next = Info[now][i].first;
			int cost = Info[now][i].second;  // cost 다리가 버틸 수 있는 중량 

			if (flagCost <= cost) {  //  가능한 물건 무게  < 다리 무게
				q.push(next);
				visited[next] = 1;
			}																	
		}
	}

	if (visited[End]) return true;
	else return false;
}

int main() {

	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		int a = 0, b = 0, c = 0;; cin >> a >> b >> c;
		Info[a].push_back({ b, c });
		Info[b].push_back({ a, c });
	}

	cin >> start >> End;

	int s = 1, e = 1000000000; // 범위 1 ~ 10억 
	
	int mid = 0;
	int ans = 0;

	while (s <= e)
	{
		mid = s + e >> 1;
		if (bfs(mid)) {
			s = mid + 1;
			ans = mid;
		}
		else {
			e = mid - 1;
		}
	}

	cout << ans;
	return 0;
}
/*
파라메트릭 서치 : 최적화 문제(어떤 값의 최대, 최소 구하는 문제 )를 결정문제(답이 yes, no)로 바꾼 뒤 이분 탐색을 이용해 최적해를 찾는 알고리즘 

//답이 [a, b]구간 내에 존재한다 할 때,
int lo = a - 1, hi = b;
while (lo + 1 < hi) {
	int mid = (lo + hi) / 2;
	if (!check(mid)) lo = mid;
	else hi = mid;
}
*/


/*
bfs가 성공했다 -> 이게 최선이거나, 더 좋은 값이 존재하겠지? -> s 구간을 현재 mid이상으로 잡아도 s는 아직 성공하는 구간값임!
*/

/*
s는 항상 성공하는 위치
e는 항상 실패하는 위치
*/
/*
파라메트릭 서치 : 최적화 문제(어떤 값의 최대, 최소 구하는 문제 )를 결정문제(답이 yes, no)로 바꾼 뒤 이분 탐색을 이용해 최적해를 찾는 알고리즘 

//답이 [a, b]구간 내에 존재한다 할 때,
int lo = a - 1, hi = b;
while (lo + 1 < hi) {
	int mid = (lo + hi) / 2;
	if (!check(mid)) lo = mid;
	else hi = mid;
}
*/


/*
bfs가 성공했다 -> 이게 최선이거나, 더 좋은 값이 존재하겠지? -> s 구간을 현재 mid이상으로 잡아도 s는 아직 성공하는 구간값임!
*/

/*
s는 항상 성공하는 위치
e는 항상 실패하는 위치
*/
````