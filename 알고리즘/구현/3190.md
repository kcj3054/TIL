#### 문제


#### 주의


#### 소스 

````
#include <bits/stdc++.h>


using namespace std;

// d는 ‘U', ‘D’, ‘R’, 'L’중에 하나이며
int n, m, k, ans;
int grid[200][200];
int dx[] = { -1, 1, 0, 0 };
int dy[] = { 0, 0, 1, -1 };
int dirMapper[4];

// -> 가 아니라 사과가 없다면 꼬리를 자르고 머리를 이동시킨 뒤에 꼬인지 확인해야한다 
// 사과를 먹더라도 꼬였는지는 확인을 해야한다 

vector<pair<int, int>> Snake;
int headX, headY;

vector<pair<int, int>> apple;

bool overlap(int x, int y);

bool InRange(int x, int y) {
	return x >= 1 && x <= n && y >= 1 && y <= n;
}


//dir 방향으로 dirCnt만큼 움직여라 

// 새로 들어온 머리와 기존의 몸통이 만나는지 확인 
bool overlap(int x, int y) {
	for (int i = 1; i < (int)Snake.size(); i++) {
		if (Snake[i].first == x && Snake[i].second == y) {
			return true;
		}
	}
	return false;
}

bool Move(int dir, int dirCnt) {

	while (dirCnt--) {
		ans++;

		int nx = headX + dx[dir];
		int ny = headY + dy[dir];

		//범위 안에있고, 겹치지않았으면 가능하다 
		
		if (!InRange(nx, ny)) return false;

		//사과가 있는 자리니 ? 
		if (grid[nx][ny] == -1) {
			
			Snake.insert(Snake.begin(), { nx, ny });
			grid[nx][ny] = 0;
		}
		else {
			Snake.pop_back();
			Snake.insert(Snake.begin(), { nx, ny });
		}
		headX = nx;
		headY = ny;
		if (overlap(nx, ny)) return false;
	} 
	return true;
}
int main() {

	cin >> n >> m >> k;

	dirMapper['U'] = 0;
	dirMapper['D'] = 1;
	dirMapper['R'] = 2;
	dirMapper['L'] = 3;

	Snake.push_back({ 1, 1 });
	headX = 1, headY = 1;

	for (int i = 0; i < m; i++) {
		int a = 0, b = 0;
		cin >> a >> b;

		grid[a][b] = -1;
	}

	for (int i = 0; i < k; i++) {
		char c = ' ';
		int a = 0;
		cin >> c >> a;
		if (Move(dirMapper[c], a) == false) break;
	}

	cout << ans;
	return 0;
}
````