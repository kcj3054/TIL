## 병합정렬

## 소스
````
#include <iostream>
#include <vector>
using namespace std;


//O(nlogn)  , 반씩 쪼개니 logn이, 모든데이터 n개를 정렬해야하니 n, -> 총 nlogn이 필요하다!

vector<int> Merge(vector<int> a, vector<int> b)
{
	vector<int> tmp;

	return tmp;
}
// [3][k][7][2][j][4][8][9]

// 병합 정렬  - > 분할 정복(dive and conquer)
// 

void MergeResult(vector<int>& v, int left, int mid, int right)
{
	// [2][3][7][k][4][8][9][j]
	// [l]          [r]
	vector<int> tmp;

	int leftidx = left;
	int rightidx = mid + 1;

	//한쪽이 먼저 빠져나오기 직전까지 계속한다!
	while (leftidx <= mid && rightidx <= right)
	{
		if (v[leftidx] <= v[rightidx])
		{
			tmp.push_back(v[leftidx]);
			leftidx++;
		}
		else
		{
			tmp.push_back(v[rightidx]);
			rightidx++;
		}
	}

	//둘중 하나가 먼저 빠져나왔다.!
	//left가 먼저 끝났으면 오른쪽에 남아 있는 데이터를 복사하자!
	if (leftidx > mid)
	{
		while (rightidx <= right)
		{
			tmp.push_back(v[rightidx]);
			rightidx++;
		}
	}
	else
	{
		while (leftidx <= mid)
		{
			tmp.push_back(v[leftidx]);
			leftidx++;
		}
	}

	//void MergeResult(vector<int>& v, int left, int mid, int right)가 left부터 정렬하는 것이니 v의 left부터 넣어준다!
	for (int i = 0; i < tmp.size(); i++)
	{
		v[left + i] = tmp[i];
	}

}
void MergeSort(vector<int>& v, int left, int right)
{
	//데이터가 하나만 남았을 경우 종료한다!
	if (left >= right) return;

	int mid = (left + right) / 2;
	MergeSort(v, left, mid);
	MergeSort(v, mid + 1, right);

	MergeResult(v, left, mid, right);
}
int main()
{
	vector<int> v;

	srand(time(0));

	for (int i = 0; i < 50; i++)
	{
		int randValue = rand() % 100;
		v.push_back(randValue);
	}

	MergeSort(v, 0, v.size() - 1);
	return 0;
}
````