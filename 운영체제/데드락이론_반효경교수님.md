## 데드락

- 프로세스가 자원을 얻지 못해서 다음 작업을 하지못하는 상태이다.

-   데드락을 생각하면 많이 떠올리는 그림인 사거리 교차로에서 서로 길을 막고 있는 차들이 있는 그림을 떠올린다..

-   일련의 프로세스들이 서로가 가진 자원을 기다리면서 block이 된 상태이다

-   많이들 본 철학자들이 식사할때 데드락 걸리는 사진이 있다 왜냐? 자신들의 것들은 주지 않으면서 계속해서 기다리니 데드락이 걸린다...

-   간단한 데드락의 예를들어보겠습니다..
    -   p1과 p2가 있을때 둘다 프로세스 A B가 필요하다 근데 P1이 A를 먼저 선점한 상태에서 기다리고 P2는 B를 먼저 선점한 상태에서 기다리면 이것은 데드락에 빠지게 된다....
    -   꼬리에 꼬리를 무는 현상이다 이런걸 환형대기라고 부르는 것같다(circular wait)..
    -   이것을 막기 위해서는 가지고 갈 프로세스들의 순서를 정해주면된다...

#### 데드락 발생 조건 4가지

-   4가지 모두 만족하면 데드락이 발생한다고 한다
    -  (1) 상호배제 mutual exclution -> 매순간 하나의 프로세스만이 자원을 사용할 수 있음
    -  (2) no preemption -> 프로세스는 자원을 스스로 내어 놓을 뿐 강제로 빼앗기지 않음

```
-  (3) 점유 대기 hold and wait -> 자신은 자원을 주지 않은 상태에서 하염없이 대기를 하는 것... 


-  (4) 순환 대기circular wait -> 자원 기다리는 프로세스끼리는 사이클이 형성 (꼬리에 꼬리를 무는 ...)
```

-   위의 방식 중에서 하나라도 만족 하지않으면 데드락에 걸리지 않는다.. 데드락은 현대 os에서는 크게 필요없다 이것을 방지하기 위해서는 많은 오버헤드가 필요해서 그렇게 하지않고 데드락을 회피하거나 아주 드물게 데드락이 발생하면 그때 해결하면된다....

#### 데드락 방지

-   mutual exclution
-   hold and wait
    -   자원을 요청할때는 어떠한 자원도 들고 있지 않은 상태에서 요청을 해야한다....
    -   자원이 필요할때 보유 자원을 손에서 놓고 다시 요청을 하면된다..
    -   (자발적으로 내놓기)
-   no preemption
    -   빼앗을 수 없어서 생기는 것이라서 빼앗으면된다..
    -   프로세스는 자원은 어차피 pcb에 저장되고 관리되니 괜찮다
    -   강제로 빼앗기는 것이다...
-   circular wait

```
- 자원에 대해서 할당 순서를 정해서 순서대로 자원을 할당하면된다.. 
```

-   그러나 이렇게하면 cpu이용율이 떨어지고 산출물도 적게된다 그래서 방지는 한다고 너무 손해가 크니 회피를 해보도록하자....

#### 데드락 회피

-   Resource Allocation 그래프 알고리즘
    -   이방식은 자원을 요청해서 할당되면 점선 , 요청을 할 수도 있는 가능성을 보여주면 실선으로 나타낸다
    -   실선이지만 만약 이것을 점선으로 나타내서 순환이 발생한다면 그것을 자원을 내놓지 않는 것이다
    -   매우 보수적으로 접근하는 것이다...

[##_Image|kage@dbL7Re/btrinAwKdyL/24II2QOJKtEIWV57m9Ol21/img.png|CDM|1.3|{"originWidth":1119,"originHeight":876,"style":"alignCenter","width":null}_##]