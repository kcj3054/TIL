## 메모리 파편화 및 해결 방법 


- 메모리 파편화는 외부파편화와 내부 파편화가 존재한다 

### 외부파편화 

-  동적으로 할당 받은 메모리들을 사용하고, 반납하고 반복되면 서 메모리들 간격에 이가나는것이다. 

- 동적 메모리 할 당시 메모리 블록들이 순차적이지 않게 할당되어, 남은 메모리 공간들이 서로 떨어져 있어서 큰 블록을 할당할 수 없을 때 발생한다. 


````c++



````

- 해결 방법은 메모리 풀링을 사용하는 것이다.
  - boost.pool로 부스트도 내부적으로 메모리 풀링을 사용할 수 있다 

- c#은 내부적으로 메모리 압축 기법을 활용하기도한다. 


- 메모리 풀링도 해결방법 

### 내부 파편화 

- 할당받은 메모리를 모두 사용하지 않고 일부가 남이있는 형태이다. 

- c++의 vector reserve를 이용해서 메모리 공간을 할당 받았지만, 실제로는 push_back을 하나만 할 경우 엄청난 비용이 낭비되는 것이다.


````c++

#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec;
    vec.reserve(1000);  // 1000개의 메모리 공간을 예약

    vec.push_back(10);  // 실제로는 1개의 요소만 사용
    std::cout << "Vector size: " << vec.size() << std::endl;
    std::cout << "Vector capacity: " << vec.capacity() << std::endl;

    return 0;
}


````