-   용어

	- 릴레이션 관점에서는 행 열을 = > (튜플, 속성)
    - 테이블 관점에서는 => (행, 칼럼)
    - 물리적 관점(메모리 또는 스토리지 관점)에서는 => (레코드, 필드)
    
    - 레코드들이 모여서 페이지가 되고 페이지가 모여서 블록이된다.

# 인덱스

-   원하는 데이터를 빠르게 찾기 위해서 돕는 도구 ex : 색인
-   인덱스를 이용하면 데이터파일을 모두 탐색하지 않아도 특정 파일을 빠르게 찾을 수 있다.
-   DBMS의 인덱스는 레코드의 키 값을 기준으로 항상 정렬되어있다.그래서 데이터를 삽입할 때마다 시간이 걸리는 대신, 정렬이 이미 되어 있기에 search는 빠르다
-   장점
-   스토리지 저장 공간에 data가 저장된다면 index에 비해 크기가 상대적으로 크다, 반면에 크기가 상대적으로 작은 index를 저장한다면 더욱 공간을 효율적으로 사용할 수 있다.
-   스토리지에 data가 저장된다고 생각해보자, 여기서 데이터에서 원하는 값을 추출하기 위해서는 일단 해당 데이터가 어디에 있는지 알아야하는데 그것을 위해서도 스토리지로부터 IO를 많이해야한다 이렇게 되면 시간이 많이 걸리고 cpu도 할 일이 많아지게된다. 그러나 index를 저장하게 된다면 index를 스토리지로부터 뽑아오고 이후에  인덱스를 통해서 원하는 정보의 위치도 찾을 수 있다.

## 기본 인덱스 (Primary Index)

- 기본 인덱스 파일에서 두개의 필드가 있는데,
	- 첫 번째 필드는 기본키에 해당하는 인덱스필드
    - 두번째는 다음 블록을 가리키는 포인터 필드가 있다.

## 클러스터 인덱스 (B+ Tree)

- 클러스터 인덱스는 리프노드에 필드 데이터를 가지고 있다.



-   참고(클러스터 인덱스와 B-Tree 구조는 다르다)
    -   index 종류에서 B-Tree index가 있다
        -   B는 "Balanced"를 의미
        -   하나의 노드에 여러자료가 배치되는 트리구조
        -   "ROOT"는 2개 이상의 자식을 가진다
-   클러스터 인덱스에서는 리프 노드에 필드관련 레코드가 저장된다, 이것을 B+트리라고한다
-   클러스터 인덱스는 반드시 키가 존재한다.
-   레코드는 다음 레코드를 가리킨느 포인터가 존재하고, 페이지에서는 다음 페이지, 이전 페이지를 가리키는 포인터가 존재한다 이러한 것을 이중화라고 하느느데 이렇게 하는 이유는 데이터를 가지고 올때 최적화된 방법을 사용하기 위해서이다)

## 보조 인덱스

-   '유일한 값을 가진 필드나 정렬되지 않은 데이터 파일'
-   mysql에서는 '클러스터 인덱스를 제외한 나머지 인덱스'를 보조 인덱스라고한다


## 다단계 인덱스

- 인덱스가 인덱스를 가리키는 2단계 이상의 레벨로 이루어진 인덱스

## 해시 인덱스

- 해시 테이블의 자료구조를 가진 인덱스

## AUTO INCREMENT

-   참조되는 기본키를 변경할 때 해당 값만 변경하고 참조하는 쪽은 변경하지 않으면 참조 무결성을 위배하게된다. 그래서 예를 들어 ON UPDATE CASCADE라는 것이 있는데 이것은 참조된 값과 참조하는 값을 같이 변경해준다. (그러나 현업에서는 기본키가 변경되어야할 일은 없어야한다)
-   AUTO INCREMENT는 자동으로 값이 1씩 증가하는 것인데 현재 만약 1, 2, 3으로 되어있고 3을 지우고 다시 증가를 시키면 3이 아니라 4가 추가된다, 즉 한번 사용한 값은 다시는 사용하지 않는 것이다.

# 정규화

-   릴레이션의 문제를 파악하여 설계를 고쳐나가는 과정을 정규화라고한다.
-   정보를 보존한 상태로 중복을 최소화하는 방향으로 데이터를 구조화하는 과정을 정규화라고한다.

\-출처 : [https://hyungjoon6876.github.io/jlog/2018/07/18/rdb-indexing.html](https://hyungjoon6876.github.io/jlog/2018/07/18/rdb-indexing.html)

\-출처 : 라떼코딩