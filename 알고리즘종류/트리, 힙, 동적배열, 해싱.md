#### 정의

-   자식 부모 이렇게 트리를 형성하는데 트리에서 정의는 정점끼리 전부 연결되어 있으면서 사이클이 존재하지 않는 그래프입니다.

#### 헷갈려던 개념

-   리프노드
    
    -   리프노드는 자식노드인 줄 알았습니다. 그러나 자식을 갖고 있지 않은 노드를 의미합니다.
-   차수
    
    -   자식의 갯수를 의미합니다 (특정 노드에 대해서)

## 이진트리

- 완전이진트리는 왼쪽노드부터 차례대로 채워지는 것이다. 그래서 공간을 효율적으로 사용할 수 있다.

- 완전이진트리는 꼭 자식이 모두 2개가 있어야만 완전이진트리가 아니다.


## maxheap, minheap

- maxheap이나 minheap이 만들어질 때는 최대 O(NlogN)의 시간이 걸린다. 왜냐?  heap을 만드는 과정에서 삽입, 삭제는 logN이 걸리는데 배열의 원소가 n개있다고 가정하면 이러한 과정을 n번해야해서 => NlogN이걸리게된다.

-  heapfiy 한 과정에서 최대 logN번 발생하기때문에 


-  heapfiy -> 
   - 현재 노드랑 자식 노드들 중에서 가장 큰 값을 찾는다 
   - 자식이 더 큰 값이라면 현재 노드A와 자식노드 B랑 교체한다
   -  교체 이후 다시  큰 값에서 다시 heapify를 진행한다
   - 만약 현재노드가 가장 큰 값이라면 heapify 종료
   - n / 2 에서 1번노드까지 실행

-  힙만들기는 -> o(nlogn)이 걸린다



- 삽입
	- 값을 삽입 할때는 일단 맨 밑에 넣는다고 가정한다.
    - 그후 heapify 과정을 통해서 자신의 부모 노드와 비교 후 값이 부모가 작다면 교체작업을 한다(max heap기준)
    - 이렇게하면 최대 O(logN)이 걸리게된다.
    
- 삭제
	- 일반적으로 값이 100% 존재 하는 것은 루트 노드
    - 여기서 맨밑의 노드를 루트 노드로 당긴다.
    - 그후 heapify(1)로 1번 노드에 대해서 max-heap과정을 수행한다
    
## 동적 배열

- 동적 배열은 정적배열에서의 삽입, 삭제 탐색 i번째 원소의 조회 역시 모두 O(1)의 시간복잡도를 가집니다.

- 배열의 길이가 고정된 경우, 같은 양의 데이터를 저장할 시 동적배열은 정적배열보다 더 많은 메모리를 사용하게된다. 


## 해싱 
