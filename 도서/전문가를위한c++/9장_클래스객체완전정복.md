
## 영의 규칙

- 기존 c++에는 5의 법칙이 존재
  - 소멸자, 복사 생성자, 이동 생성자, 복사 대입연산자, 이동 대입연산자에 대한 것.
  - 모던 c++에서는 0의 규칙이 존재 
    - 5의 법칙으로 하려면 메모리를 동적으로 할당해야하지만 모던 c++에서는 그렇게하지말라고한다, 표준라이브러리 컨테이너를 사용하자. 

## ㅈㄷ

## 참조 한정 메서드 

````c++
#include <iostream>
#include <string>

using namespace std;
/*
* 복사는 메모리를 새로 할당하고 데이터를 복사하는 과정을 거치므로 성능이 떨어질 수 있습니다.
이동은 기존 데이터를 새로 할당하지 않고 기존 메모리 주소를 이전하기 때문에 성능이 훨씬 더 좋습니다.
*/
class TextHolder
{
public:
	// 생성자에서도 move로 하는 이유? .
	// move를 하지 않으면 전달된 text는 복사됩니다. 
	// 즉, text가 메모리에 할당된 문자열 데이터를 그대로 복사하여 m_text에 저장하게 됩니다. 
	TextHolder(string text) : m_text( move(text)) {}

	//l - value는 const &로 처리,  r - value는 &&로 처리 
	const string& getText() const & { return m_text; }
	string&& getText() && { return move(m_text); }
private : 
	string m_text;
};

int main()
{
	//string의 임시 객체가 생성되나 ? 
	TextHolder	textHolder{ "Hello World" };

	cout << textHolder.getText() << endl;
	cout << TextHolder{ "Hello world" }.getText() << endl; // 생성자 탄 후 -> r- value로 탄다.
	cout << move(textHolder).getText() << endl;

	return 0;
}
````

## const 메서드

- const로 선언하지 않은 객체에 대해서는 const 메서드와, 비 const 메서드 둘다 호출할 수 있다.
- 반면 객체를 const로 선언했다면 const 메서드만 호출할 수 있다. 

````c++
#include <iostream>
#include <string>

using namespace std;

class SpreadsheetCell
{
public:
    SpreadsheetCell(double initialValue) : value(initialValue) {}

    // const 멤버 함수 (객체의 값을 변경하지 않음)
    double getValue() const { return value; }

    // 비-const 멤버 함수 (값을 변경할 수 있음)
    void setValue(double newValue) { value = newValue; }

private:
    double value;
};

int main()
{
    SpreadsheetCell cell(10.0);  // 비-const 객체

    // 비-const 객체는 const와 비-const 메서드 모두 호출 가능
    cout << "Cell value: " << cell.getValue() << endl;  // const 메서드 호출
    cell.setValue(20.0);  // 비-const 메서드 호출
    cout << "Updated cell value: " << cell.getValue() << endl;

    // const로 선언된 객체
    const SpreadsheetCell constCell(30.0);

    // const 객체는 const 메서드만 호출 가능
    cout << "Const cell value: " << constCell.getValue() << endl;

    // constCell.setValue(40.0); // 오류: 비-const 메서드는 호출 불가

    return 0;
}

````

## mutable 데이터 맴버 

- const 메서드 내에서 데이터를 변경하고싶을 때 대상 맴버 변수를 mutable로 선언하면된다 

````c++
#include <iostream>
#include <string>

using namespace std;

class SpreadsheetCell
{
public:
    SpreadsheetCell(double initialValue) : value(initialValue) {}

    // const 멤버 함수 (객체의 값을 변경하지 않음)
    double getValue() const 
    {
        m_numAceesees++; // mutable 변수가 아닐 경우 error 발생 
        return value; 
    }

    // 비-const 멤버 함수 (값을 변경할 수 있음)
    void setValue(double newValue) { value = newValue; }

private:
    double value;
    mutable size_t m_numAceesees{ 0 };
};

int main()
{
   

    return 0;
}

````

## static 데이터 맴버

- c++에서 static 데이터 맴버는 객체가 아닌 클래스에 속한다. 
- 그렇기에 SpreadSheet를 예로 들때 모든 cell이 ID가 고유해야 돼, 이상태에서 ID를 만들려면 객체 생성하고 객체마다 ID넣고, 각 객체끼리 동기화해줘야한다.... 이렇게말고 SpreadSheet 자체에 static를 id로 선언하게된다면 쉽게 해결된다. 

- 


## 인라인 메서드 

````c++

````

## 디폴트 매개변수 

````c++
#include <iostream>
#include <string>

using namespace std;

class SpreadSheet
{
public:
	//default 매개 인수는 제일 끝 오른쪽 매개변수 부터 적용된다. 
	SpreadSheet(size_t width = 100, size_t height = 100) : width(width), height(height) {}

public:
	const size_t getWitdh() const{ return width; }
	const size_t getHeight() const{ return height; }

private:
	size_t width = 0;
	size_t height = 0;
};

int main()
{
	SpreadSheet s1;
	cout << s1.getHeight() << endl; // 100

	SpreadSheet s2{ 5 };
	cout << s2.getHeight() << endl; // 100 

	SpreadSheet s3{ 5, 6 };
	cout << s3.getHeight() << endl; // 6

	return 0;
}
````