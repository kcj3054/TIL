## memory 

- c++에서 메모리 누수를 확인할 수 있다.



````c++

#define _CRTDBG_MAP_ALLOC

#include <iostream>
#include <memory>
#include <crtdbg.h>  // 메모리 릭 체크 헤더

using namespace std;

class Simple
{
public:
	void go()
	{
		cout << "Simple::go()" << endl;
	}
private:
	int _data;
};

void leaky()
{
	Simple* mySimple = new Simple();
	mySimple->go();
	// delete mySimple;  // 메모리 해제
}

int main()
{
	for (int i = 0; i < 100; ++i)
	{
		leaky();
	}

	// 메모리 누수 보고
	_CrtDumpMemoryLeaks();

	return 0;
}


````

![](./../전문가를위한c++_이미지/메모리누수.png)


- 위코드에서 Simple 개체를 생성했지만 delete를 하지 않은 모습으로 인해 memory leak이 감지됐다..



## unique_ptr

- unique_ptr은 개체를 소유권을 하나만 유니크하게 인정하는 스마트 포인터이다.

- 하나의 소유권만 가능하기에  = 연산이 기본적으로는 막혀있자만, std::move의 이동 시멘틱을 이용한다면 가능하다.

- 컴파일러는 템플릿 타입을 클래스 템플릿 생성자로 전달된 인수를 보고 추론할 수있도록 CTAD이 적용되지만 unique_ptr과 shared_ptr에는 적용되지않는다.


### 사용 

````c++
#define _CRTDBG_MAP_ALLOC

#include <iostream>
#include <memory>
#include <vector>

using namespace std;

class Simple
{
public:

	Simple() = default;

	void go()
	{
		cout << "Simple::go()" << endl;
	}
private:
	int _data;
};

void foo(unique_ptr<Simple> p)
{
	p->go();
}

int main()
{
	auto myuniqu_ptr = make_unique<Simple>();

	vector<int> v = { 1, 2, 3, 4, 5 };
	//CTAD - Class Template Argument Deduction
	vector v { 1, 2, 3, 4, 5 };

	//CTAD UNIQUE_PTR
	auto myuniqu_ptr2 = make_unique<Simple>();


	//C++17이전에는  memory 누수가 발생했음 ..  Simple 생성자에서 exception이 발생했을 때 ... 
	foo(unique_ptr<Simple>(new Simple()));
	//그래서 아래와 같이 사용했지만, 이제는 위 방식도 가능함.
	foo(make_unique<Simple>());





	return 0;
}

````

### unique_ptr_reset_release

````c++

#define _CRTDBG_MAP_ALLOC

#include <iostream>
#include <memory>
#include <vector>

using namespace std;

class Simple
{
public:

	Simple() = default;

	void go()
	{
		// cout << "Simple::go()" << endl;
	}

	void setData(int data)
	{
		_data = data;
	}
private:
	int _data;
};

void foo(unique_ptr<Simple> p)
{
	p->go();
}

int main()
{
	auto myuniqu_ptr2 = make_unique<Simple>();


	//myuniqu_ptr2.reset(); // resource 해제 후 nullptr로 초기화 
	// myuniqu_ptr2->setData(100); // nullptr이므로 런타임 에러 발생

	myuniqu_ptr2.reset(new Simple()); // resource 해제 후 nullptr로 초기화  후 새로운 객체로 초기화
	myuniqu_ptr2->setData(100); //정상동작 

	return 0;
}


````



## 메모리 누수

- new delete를 빠짐 없이 사용하더라도 문제가 발생할 수 있다.

- 포인터를 받는 매개변수에서 기존의 원본 영역 메모리를 제거하지 않고, 다른 메모리 공간을 가리키게된다면 기존의 영역은 미아가 된다 

````c++
#define _CRTDBG_MAP_ALLOC

#include <iostream>
#include <crtdbg.h>

using namespace std;

class Simple
{
public:
	Simple() { m_intPtr = new int; }
	~Simple() { delete m_intPtr; }

	void setValue(int value) { *m_intPtr = value; }

private:
	int* m_intPtr;
};

void doSomething(Simple* outSimplePtr)
{
	outSimplePtr = new Simple(); // 여기서 문제가 발생함 기존제 가리키전 Simple 객체는 가리키지 않음.. 
}

int main()
{

	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);  // 메모리 누수 감지 활성화

	Simple* simple = new Simple{};
	doSomething(simple);



	delete simple;
	return 0;
}
````

## Shared_ptr

- https://www.youtube.com/watch?v=dtEGd30T8Rk