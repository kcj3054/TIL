## memory 

- c++에서 메모리 누수를 확인할 수 있다.



````c++

#define _CRTDBG_MAP_ALLOC

#include <iostream>
#include <memory>
#include <crtdbg.h>  // 메모리 릭 체크 헤더

using namespace std;

class Simple
{
public:
	void go()
	{
		cout << "Simple::go()" << endl;
	}
private:
	int _data;
};

void leaky()
{
	Simple* mySimple = new Simple();
	mySimple->go();
	// delete mySimple;  // 메모리 해제
}

int main()
{
	for (int i = 0; i < 100; ++i)
	{
		leaky();
	}

	// 메모리 누수 보고
	_CrtDumpMemoryLeaks();

	return 0;
}


````

![](./../전문가를위한c++_이미지/메모리누수.png)


- 위코드에서 Simple 개체를 생성했지만 delete를 하지 않은 모습으로 인해 memory leak이 감지됐다..



## unique_ptr

- unique_ptr은 개체를 소유권을 하나만 유니크하게 인정하는 스마트 포인터이다.

- 하나의 소유권만 가능하기에  = 연산이 기본적으로는 막혀있자만, std::move의 이동 시멘틱을 이용한다면 가능하다.

- 컴파일러는 템플릿 타입을 클래스 템플릿 생성자로 전달된 인수를 보고 추론할 수있도록 CTAD이 적용되지만 unique_ptr과 shared_ptr에는 적용되지않는다.


### 사용 

````c++
#define _CRTDBG_MAP_ALLOC

#include <iostream>
#include <memory>
#include <vector>

using namespace std;

class Simple
{
public:

	Simple() = default;

	void go()
	{
		cout << "Simple::go()" << endl;
	}
private:
	int _data;
};

void foo(unique_ptr<Simple> p)
{
	p->go();
}

int main()
{
	auto myuniqu_ptr = make_unique<Simple>();

	vector<int> v = { 1, 2, 3, 4, 5 };
	//CTAD - Class Template Argument Deduction
	vector v { 1, 2, 3, 4, 5 };

	//CTAD UNIQUE_PTR
	auto myuniqu_ptr2 = make_unique<Simple>();


	//C++17이전에는  memory 누수가 발생했음 ..  Simple 생성자에서 exception이 발생했을 때 ... 
	foo(unique_ptr<Simple>(new Simple()));
	//그래서 아래와 같이 사용했지만, 이제는 위 방식도 가능함.
	foo(make_unique<Simple>());





	return 0;
}

````

### unique_ptr_reset_release

````c++

#define _CRTDBG_MAP_ALLOC

#include <iostream>
#include <memory>
#include <vector>

using namespace std;

class Simple
{
public:

	Simple() = default;

	void go()
	{
		// cout << "Simple::go()" << endl;
	}

	void setData(int data)
	{
		_data = data;
	}
private:
	int _data;
};

void foo(unique_ptr<Simple> p)
{
	p->go();
}

int main()
{
	auto myuniqu_ptr2 = make_unique<Simple>();


	//myuniqu_ptr2.reset(); // resource 해제 후 nullptr로 초기화 
	// myuniqu_ptr2->setData(100); // nullptr이므로 런타임 에러 발생

	myuniqu_ptr2.reset(new Simple()); // resource 해제 후 nullptr로 초기화  후 새로운 객체로 초기화
	myuniqu_ptr2->setData(100); //정상동작 

	return 0;
}


````



## 메모리 누수

- new delete를 빠짐 없이 사용하더라도 문제가 발생할 수 있다.

- 포인터를 받는 매개변수에서 기존의 원본 영역 메모리를 제거하지 않고, 다른 메모리 공간을 가리키게된다면 기존의 영역은 미아가 된다 

````c++
#define _CRTDBG_MAP_ALLOC

#include <iostream>
#include <crtdbg.h>

using namespace std;

class Simple
{
public:
	Simple() { m_intPtr = new int; }
	~Simple() { delete m_intPtr; }

	void setValue(int value) { *m_intPtr = value; }

private:
	int* m_intPtr;
};

void doSomething(Simple* outSimplePtr)
{
	outSimplePtr = new Simple(); // 여기서 문제가 발생함 기존제 가리키전 Simple 객체는 가리키지 않음.. 
}

int main()
{

	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);  // 메모리 누수 감지 활성화

	Simple* simple = new Simple{};
	doSomething(simple);



	delete simple;
	return 0;
}
````

## Shared_ptr

- https://www.youtube.com/watch?v=dtEGd30T8Rk

## placement_new 


- 기존의 new 연산은 메모리 할당 -> 객체를 생성자를 이용하여 초기화를 진행한다. 그렇지만 placement new를 이용하게된다면 미리 할당 된 메모리에 개체를 생성만 하면 되기에 하나의 스텝이 줄어들어서 메모리 관리에 효율성이 높아진다. 

````c++
#include <iostream>

using namespace std;

class MyClass
{
public:
	MyClass(int v) : value(v) { cout << "constructed : " << value << endl; }
	~MyClass() { cout << "Destroyed: " << value << endl; }

private:
	int value = 0;
};

int main()
{
	void* mem = operator new(sizeof(MyClass));

	auto target = new(static_cast<MyClass*>(mem)) MyClass(20);


	return 0;
}

````


## std:: move

````c++
#include <iostream>
#include <string>
#include <memory>

using namespace std;


class MyClass {
public:
	MyClass(int value) : value_(value) {
		std::cout << "MyClass(" << value_ << ") constructed\n";
	}
	~MyClass() {
		std::cout << "MyClass(" << value_ << ") destroyed\n";
	}

	int getValue() const { return value_; }

private:
	int value_;
};


int main()
{
	std::string str = "Hello world";
	std::string moved_str = std::move(str);

	cout << "moved str : " << moved_str << endl; // 소유권이 이전 됌 , std::move 시멘틱을 활용하면 모든 것을 복사 하지 않음 
	cout << "origin str : " << str << endl; // 더 이상 유효하지않음 출력 안돼 

	// 메모리 포인터나 리소스는 이동된 객체로 넘겨짐.
	// 기존 객체는 '비어 있는' 상태로 남게 됩니다.

	//ex2 포인터는 별  의미 없다 

	int* p1 = new int(10);
	int* p2 = std::move(p1);

	cout << "p2 : " << p2 << endl;
	cout << "p1 : " << p1 << endl;

	*p1 = 200;

	cout << *p2 << endl;


	// std::move는 큰 개체 복사 대신 소유권을 이전하여 데이터 복사 비용을 줄여서 성능을 향상하는 목적이 도모됌 

	//ex 3 unique_ptr  std::move 
	std::unique_ptr<MyClass> ptr1 = make_unique<MyClass>(10);

	//소유권이전
	//기본적으로 unique_ptr은 = 연산이 불가능하다 , 왜냐 독립 유니큰 포인터이기에 그렇다 하나의 리소스 단일 독점 
	unique_ptr<MyClass> ptr2 = std::move(ptr1);

	if (ptr1 == nullptr)
	{
		cout << "ptr1 is nullptr" << endl;
	}




	return 0;
}
````

- std::move는 주어진 객체를 r-value로 취급하여 이동할 수 있도록 합니다. 즉, 소유권이 더 이상 원본 객체에 필요하지 않음을 나타냅니다.
