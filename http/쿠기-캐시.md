#### 쿠키 - 보안

-   secure
    
    -   secure 적용하면 htts인 경우에만 전송
-   HttpOnly
    
    -   자바스크립트에서 접근 불가, http 전송에만 사용

# 캐시

-   캐시가 없을 경우 요청할때마다 이전의 요청을 똑같이 헤더부, 바디부 포함해서 응답해주어야한다 (데이터가 변경되지 않아도 똑같이 응답을 해주어야한다)
    
-   캐쉬를 적용한다면
    
    -   서버에서 응답을 보낼때 cache-control을 가지고 있다, 그리고 클라이언트에서는 브라우저 캐시저장소에 응답결과를 캐시에 저장을 해놓고, (2) 다시 요청을할때 우선적으로 캐시 저장소를 뒤져서 해당 내용이 있으면 가지고 온다
        
    -   이러한 방식으로 네트워크를 사용하지 않아도된다,
        
    -   브라우저 로딩속도가 빠르다
        

-   캐쉬의 시간이 초과한다면 최신의 정보가 아닐 수도 있기때문에 서버를 통해서 다시 조회해서 캐시를 갱신해야한다.

-   캐시 시간이 초과해서 다시 요청을 해야하는데 ... 같은 이미지인데 굳이 또 헤더 바디 다 요청해야하는가?..... 그렇지않다
    
-   서버에서 response할때 cache-control과, 검증헤더 (Last-Modified)를 같이 보내준다 또한 클라이언트에서 요청을 보낼때는 조건부 요청(if-modified-since)을 포함해서 보내는데 서버의 데이터가 갱신되지 않았으면 304 Not Modified + 헤더 메타 정보만 응답을 한다 이때 바디데이터는 없다 (데이터의 갱신이 없으니 바디가 없지..!!!), 이렇게 정보를 받으면 클라이언트를 메타정보를 갱신하고 다시 캐시 저장소에 있는 데이터를 재사용하면서 더 효율적이게된다..
    

#### Last-Modified, if-Modified-Since 단점

-   둘다 기반의 로직을 사용한다, 이러한 것을 통해서 데이터를 수정해서 날짜가 다르지만 데이터는 동일한 상태에서, 서버에서 별도로 캐시 로직을 관리할 수 있는 방법이 필요하다 이것이 Etag이다.

-   Etag, 캐시용 데이터에 임의의 이름을 달아둬서 데이터가 변경되면 Etag를 변경하면된다(Hash를 다시 생성), 이렇게 시간 대신해서 Etag를 사용하면 시간을 확인하는 것이아니라 단순히 Etag를 보내서 클라이언트랑 서버랑 동일하면 다시 캐시저장소에서 사용하면되는 것이다.
    
-   Etag , 캐시 제어 로직을 서버에서 완전히 관리(클라이언트는 단순히 Etag 값을 서버에 전달하기만 한다)
    

# 프록시 캐시