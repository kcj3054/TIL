## 캐스팅에 관하여...

- 캐스팅에는 static_cast, const_cast<>(), dynamic_cast<>()..가 있다.

- static_cast<>()는 누가봐도 될 것같으면 가능하다, 타입변환이나 다운캐스팅.

- dynamic_cast<>()는 상속 관계에서의 안전한 형 변환이다. 

    - RTTI 다형성을 활용하는 방식, virtual함수를 하나라도 만들었으면 객체 메모리에 가상함수 테이블 주소가 기입된다. dynamic_cast를 사용했을 때 잘못된 타입으로 캐스팅을 하면 nullptr이 반환되어서 타입이 맞는지 확인할 때유용하다.





## 소스
````
#include <bits/stdc++.h>

using namespace std;

/*
캐스팅의 종류
1) static_cast
2) dynamic_cast
3) const_cast
4) reinterpret_cast
*/

class Player
{
public:
	virtual ~Player(){}
};

class Knight : public Player
{

};
class Archer : public Player
{

};

void PrintName(char * Name)
{

}
int main()
{
	//static_cast : 타입 원칙에 비춰볼때 누가봐도 가능한 경우일때만 가능하다. 
	/*
	1) int < - > float
	2) Player * - > Knight*(다운캐스팅) 
	*/

	int hp = 100;
	int maxHp = 200;
	float ratio = static_cast<float> (hp) / maxHp;  // 실수연산이 우선순위가 높아서 float로 변환된다 

	// 부모에서 자식으로 
	Player * p = new Knight();
	Knight * k1 = (Knight*)p;

	//dynamic_cast : 상속 관계에서의 안전한 형 변환 
	/*
	RTTI(RunTime Type Information)
	-다형성을 활용하는 방식 
	virtual함수를 하나라도 만들면, 객체 메모리에 가상 함수 테이블 주소가 기입된다.
	잘못된 타입으로 캐스팅 했으면 nullptr반환
	*/
	Knight* k2 = dynamic_cast<Knight*> (p); // p가 원래 Knight*타입이 아니면 k2를 nullptr로 반환된다 주로 맞는 타입으로 캐스팅 했는지 확인에 유용.

	//PrintName에는 char *,  kcj3054는 const char *따라서 kcj3054를 넘기면 오류가 발생 
	PrintName(const_cast<char*>("kcj3054"));
	return 0;
}
````