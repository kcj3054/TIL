## satic

	-  자바의 정석을 보면 변수에 인스턴스 변수, 클래스변수가 있다 여기에서 클래스변수를 보자
    - 클래스 변수 : 클래스 선언시 static 키워와 함께 선언된 필드, 이 필드는 모든 인스턴스들이 공유하는 값이다 즉 클래스 하나에 하나의 값이라는 것이다. 


## 왜 Long, Integet reference type을 사용하는가?

- reference type에는 null을 사용할 수 있지만 primitive type에는 null을 할당 할 수 없다 그러면 primitive type의 null에 .를 찍으면 말 그대로 널포인트 exception이 터지는 것이다. 

## hashMap

- 자바의 Map인터페이스를 상속해서 구현한 것들 중에서 hashMap, hashTable, ConcurrentHashMap이 있다. 강의를 듣다보면 hashMap은 멀티스레드 환경에서 쓰면 안된다고 한다 이때는 ConcurrentHashMap을 써야한다고한다. 왜냐? ConcurrentHashMap은 thread - safe해서 연산이 이루어질 때도 값의 atomic이나 정합성을 유지해 주기때문이다. 


- hashTable도 스레드 세이프하기는 하다 그러나 차이점이 있다. hashTable은 주요 메소드에 synchronized 키워드가 붙어 있어서 비용측면에서 조금더 비싸다고한다. 또한 hashTable은 key, value에 null을 허용하지않는다 (hashMap은 null을 허용)

- 


## 스트림

-   스트림이란? -> 컬렉션 요소들을 하나씩 참조해 람다식으로 처리할 수 있는 반복자, 데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 값 요소
-   장점
    -   명시적이다
    -   `double average = emps.stream() .filter(emp -> emp.getSalary() > 100000000) .mapToInt() .average() .orElse(0);`
    -   각각의 메소드명으로 명시적으로 기능을 알 수 있다.
    
-   사용법
    -   1.  stream(스트림생성) 2. filter, map -> 데이터 처리 연산 3. collect 최종연산
-   flatMap
    -   List manyFish = fishes.stream()
        
        ```
                                .map()
                                .flatMap(List::stream)
                                .collect(Collectors.toList())
        ```
        
        -   리스트를들 묶는다고 생각하면 좋다 묶고 -> collect로 연결시킨다.
-   reduce
-   `- reduce(10(초기값), (acc, x) -> acc + x) => acc + x에 해서 값들이 더해진다.`

## 불변객체, final 키워드

-   불변객체, final
    -   자바에서 final를 붙이면 변경될 필요가 없는 부분에는 final을 붙여서 실수를 방지할 수 있다. -> 안정성, 버그 발생을 줄임,
    -   불변객체는 객체에 final을 붙인 것이다. -> 한 번 생성되면 상태를 수정할 수 없는 객체이다.
-   불변객체 예제

```
package com.example.socket;

import java.lang.management.MonitorInfo;

public final class App {
    private final int money;


    private App(final  int money){
        this.money = money;
    }

//    public 정적 팩토리 메서드
    public static App of(final  int money) {
        return new App(money);
    }
}
```

-   불변객체를 사용하면 스레드 동기화 문제를 방지할 수 있다. 왜냐 ?

```
package com.example.socket;

import java.lang.management.MonitorInfo;

public final class Money {
    private final int money;


    private Money(final  int money){
        this.money = money;
    }

//    public 정적 팩토리 메서드 ?
    public static Money of(final  int money) {
        return new Money(money);
    }


    public Money plus(final  int money) {
        return new Money(this.money + money);
    }
}
```

-   위의 예제 plus에서 plus를 호출할 때마다 새롭게 불변객체를 만들어서 서로에게 영향을 끼치지 않는다.
-   불변객체는 사용해야한다 -> 신뢰성 있는 코드를 만들 수 있고, 오류가 생길 여지(멀티스레딩에서 동시성 문제)도 적다
-   출처 : 우테톡, 모던 자바 인 액션,  
	- https://jdm.kr/blog/197