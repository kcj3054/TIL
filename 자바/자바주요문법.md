## satic


-  자바의 정석을 보면 변수에 인스턴스 변수, 클래스변수가 있다 여기에서 클래스변수를 보자
- 클래스 변수 : 클래스 선언시 static 키워와 함께 선언된 필드, 이 필드는 모든 인스턴스들이 공유하는 값이다 즉 클래스 하나에 하나의 값이라는 것이다.
- 클래스 변수라고 붙여진 이유는 객체를 통해서 접근하는 것이 아니라  객체를 생성하지 않더라도 클래스를 통해서 바로 접근 가능하기 때문이다. 

- 밑의 Student 캘르스를 보면 static으로 선언된 getSerialNum()을 보게되면 해당 메서드 안에서는 인스턴스변수인 studentName을 사용할 수 없다 이유는 메모리 할당시기를 보면 알 수 있다, 인스턴스 변수는 해당 객체가 new 된 후에 메모리의 heap영역에 할당되지만, static 이 붙여진 것은 프로그램에 메모리에 로딩될 때 바로 같이 code영역으로 메모리가 할당되게 되어서, 객체가 만들어지기 전부터 static이 붙여진 것들은 메모리가 할당된다.  

- 지역변수는 스태틱메모리에 할당
````
public class Student {

    private static int serialNum = 10000;

    int studentID;
    String studentName;

    public Student() {
        serialNum++;
        studentID = serialNum;
    }
    // static 변수는 메모리가 데이터 영역에 생긴다.
    public static int getSerialNum() {
        int i = 10; //
        //static 메서드 안에서는  인스턴스 변수는 사용할 수 없다
        //studentName = "홍길동";
        return serialNum;
    }
}
````


- 밑의 예시를 보면 생성된 객체 studentK를 통해서 static함수를 접근할 수도 있지만, 클래스인 Student를 통해서 바로 static 메서드로 접근할 수 있다.  
````
Student studentK = new Student();
System.out.println(studentK.getSerialNum());

System.out.println(Student.getSerialNum());
````

## ToString

- ToStringd을 재정의하여 사용한다면 해당 객체의 필드 값들이 호된다.

- 그러나 String은 재정의하지않고 사용해되 바로 필드값이 나오게된다, 왜냐하면 내부에 이미 toString이 재정의 되어있기 때문이다.

````
 //String은 내부에 이미 toString이 재정의 되어있다
        String str = new String("test");
        System.out.println(str);  // test가 출련된다.
````
## Equals

- 일반적으로 자바는 '==' 연산은 객체가 가리키는 레퍼런스가 같은지를 묻는 것이다. 그래서 new를 두번해서 같은 타입의 객체를 2개만들면 객체마다 주소가 다르기때문에 'false'가 나오게된다, (다른 힙메모리에 있어서 주소값이 다르다.)

````
Student student1 = new Student(1001, "aaa1");
Student student2 = new Student(1001, "aaa2");
System.out.println(student1 == student2);   // false가 나오게된다. 
````

- equals 메소드를 보자, 일반적으로 equals의 원래 구현도 == 와 동일해서 재정의를 통해서 구현해야한다 

````
-> equals 재정의 부분 
    @Override
    public boolean equals(Object obj) {
        if(obj instanceof Student) {
            Student student = (Student) obj;

            if(student.studentID == studentID) return true;
            else return false;
        }
        return false;
    }
==================================================================
 System.out.println(student1.equals(student2));  // true 발생
````


- 일반저그올 논리적으로 동일함을 위해 equals() 메서드를 재정의 하였다면 hashCode() 메서드도 재정의하여 동일한 값이 반환 되도록 해야한다. 






## 왜 Long, Integet reference type을 사용하는가?

-   reference type에는 null을 사용할 수 있지만 primitive type에는 null을 할당 할 수 없다 그러면 primitive type의 null에 .를 찍으면 말 그대로 널포인트 exception이 터지는 것이다.

## 다형성

-  다형성에서 알아야할 것은 가상함수이다. 만약 부모에 move()라는 메서드가 있고 자식이 move()함수를 재정의 했다고하면 다형성을 통해서 만들어진 객체는 부모의 것만 호출할 수 있는데 부모의 move가 호출되는 것이 아니라 자식을 통해 재정의된 move가 호출된다. 이것의 이유는 가상함수가 가리키는 레퍼런스가 다르기때문이다. 


- public void moveAnimal(Animal animal)는 매개변수쪽에서 호랑이 사람을 다 받을 수 있는 부모형태인 Animal 타입으로 받아준다. 

-  animal.move()를 통해서 재정의된 것의 move를 호출할 수 있지만, 자식 고유한 메서드를 호출하고 싶을때도있다 이럴때는 다운캐스팅을 한 후에 해당 객체의 메서드를 호출하면된다. 예를 들면 밑의 코드에서 read()가 그 예이다.



````
class Animal {
    public void move() {
        System.out.println("동물이 움직입니다.");
    }
}

class Human extends Animal {
    @Override
    public void move() {
        System.out.println("사람이 두발로 걷습니다");
    }
    
    public void readBook() {
        System.out.println("사람이 책을 읽습니다");
    }
}

class Tiger extends Animal {
    @Override
    public void move() {
        System.out.println("호랑이가 네발로 뜁니다.");
    }

    public void hunting() {
        System.out.println("호랑이가 사냥을합니다");
    }
}

public class AnimalTest1 {

    public static void main(String[] args) {
        AnimalTest1 test = new AnimalTest1();

        //동일한 메소드를 호출하지만 다양한 형태를 가질 수 있다  다형성
        test.moveAnimal(new Human());
        test.moveAnimal(new Tiger());


        List<Animal> animals = new ArrayList<>();
        animals.add(new Tiger());

    }

    public void moveAnimal(Animal animal) {
        //상속 가상함수 .. .
        animal.move();

        //다운 캐스팅
        // 하위클래스가 상위클래스로 변환하는 것은 명시적으로 이루어진다,
        // 다시 원래 자료형인 하위 클래스로 형 변환 하려면 명시적으로 다운캐스팅을 해야함 ,
        //instanceof -> 원래 인스턴스 타입을 체크하는 예약어가 instanceof이다.
        if(animal instanceof Human) {
            Human human = (Human) animal;
            human.readBook();
        }
        else if(animal instanceof  Tiger) {
            Tiger tiger = new Tiger();
            tiger.hunting();
        } else{
            System.out.println("지원되지 않는 기능입니다 ");
        }
    }
}

````

## hashMap

- 일반적인 hash에 대해서 조금 짚어서보자
	- 해쉬 코드는 검색을 할 때 O(1)만에 검색이 가능해서 매우 유용한 알고리즘이다 
    - 대표적인 형태는 index(저장위치) = hash(kye)  ->hash함수에 특정 키 값을 넣으면 저장위치를 빠르게 알 수 있다
    - jvm에서 heap관리르 할 때 hash로 관리한다.

-   자바의 Map인터페이스를 상속해서 구현한 것들 중에서 hashMap, hashTable, ConcurrentHashMap이 있다. 강의를 듣다보면 hashMap은 멀티스레드 환경에서 쓰면 안된다고 한다 이때는 ConcurrentHashMap을 써야한다고한다. 왜냐? ConcurrentHashMap은 thread - safe해서 연산이 이루어질 때도 값의 atomic이나 정합성을 유지해 주기때문이다.

-   hashTable도 스레드 세이프하기는 하다 그러나 차이점이 있다. hashTable은 주요 메소드에 synchronized 키워드가 붙어 있어서 비용측면에서 조금더 비싸다고한다. 또한 hashTable은 key, value에 null을 허용하지않는다 (hashMap은 null을 허용)

## 스트림

-   스트림이란? -> 컬렉션 요소들을 하나씩 참조해 람다식으로 처리할 수 있는 반복자, 데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 값 요소
-   장점
    -   명시적이다
    -   `double average = emps.stream() .filter(emp -> emp.getSalary() > 100000000) .mapToInt() .average() .orElse(0);`
    -   각각의 메소드명으로 명시적으로 기능을 알 수 있다.
-   사용법
    -   1.  stream(스트림생성) 2. filter, map -> 데이터 처리 연산 3. collect 최종연산
-   flatMap
    -   List manyFish = fishes.stream()
        -   리스트를들 묶는다고 생각하면 좋다 묶고 -> collect로 연결시킨다.
    -   `.map() .flatMap(List::stream) .collect(Collectors.toList())`
-   reduce
-   `- reduce(10(초기값), (acc, x) -> acc + x) => acc + x에 해서 값들이 더해진다.`

## 불변객체, final 키워드

-   불변객체, final
    -   자바에서 final를 붙이면 변경될 필요가 없는 부분에는 final을 붙여서 실수를 방지할 수 있다. -> 안정성, 버그 발생을 줄임,
    -   불변객체는 객체에 final을 붙인 것이다. -> 한 번 생성되면 상태를 수정할 수 없는 객체이다.
-   불변객체 예제

```
package com.example.socket;

import java.lang.management.MonitorInfo;

public final class App {
    private final int money;


    private App(final  int money){
        this.money = money;
    }

//    public 정적 팩토리 메서드
    public static App of(final  int money) {
        return new App(money);
    }
}
```

-   불변객체를 사용하면 스레드 동기화 문제를 방지할 수 있다. 왜냐 ?

```
package com.example.socket;

import java.lang.management.MonitorInfo;

public final class Money {
    private final int money;


    private Money(final  int money){
        this.money = money;
    }

//    public 정적 팩토리 메서드 ?
    public static Money of(final  int money) {
        return new Money(money);
    }


    public Money plus(final  int money) {
        return new Money(this.money + money);
    }
}
```

-   위의 예제 plus에서 plus를 호출할 때마다 새롭게 불변객체를 만들어서 서로에게 영향을 끼치지 않는다.
-   불변객체는 사용해야한다 -> 신뢰성 있는 코드를 만들 수 있고, 오류가 생길 여지(멀티스레딩에서 동시성 문제)도 적다
-   출처 : 우테톡, 모던 자바 인 액션,
    -   [https://jdm.kr/blog/197](https://jdm.kr/blog/197)